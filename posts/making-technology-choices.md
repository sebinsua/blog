---
title: Making technology choices
slug: making-technology-choices
date: "2021-11-12"
---

Back in 2010, the adage “the right tool for the job” was [prevalent within the developer community](https://hn.algolia.com/?dateEnd=1293753600&dateRange=custom&dateStart=1225238400&page=1&prefix=false&query=%22use%20the%20right%20tool%20for%20the%20job%22&sort=byPopularity&type=comment), but by 2015 it was seen by many as motivated reasoning and in general harmful advice. Instead it’s common to hear that we should [“Choose Boring Technology”](https://mcfunley.com/choose-boring-technology) and ["optimize [your] engineering decisions for iteration speed"](https://twitter.com/dorkitude/status/1446170171694010373).

My view is that the adage “the right tool for the job” suffered from being transmitted by engineers in an almost folkloric manner. It’s a truism (“_obviously_ you want to pick the right tool!”) but in practice was often wrong since shoe-horning an old bit of common wisdom into the domain of software engineering gave license to the self-interests of software engineers who could avoid thinking about its costs (operational complexity, training/ramp-up costs of employees, etc).

On the other hand, “Choose Boring Technology” treats technology choices as if the only system they interact with is a technical one and human incentives can be disregarded — it pays no attention to why “the right tool” was so-often endorsed, and how this related to the polyglot movement (both were, in a sense, marketing that allowed startups and employees that wanted to chart uncharted waters to find each other). Boring is also a misnomer — what is meant is “well-understood” but the word choice is being used to frame the domain as one in which technologies can either be “shiny” or “boring” — which isn’t the primary frame that I'd use to evaluate technology.

While reducing operational complexity, using technologies that are flexible and avoiding unknown-unknowns is very important and good evidence that “Choose Boring Technology” is a sensible approach, we should also pay careful attention to whether our choices result in happy developers. Retention is important to the long-term maintenance of knowledge within a company, and developers that don’t feel like they’re learning anything new or that feel stifled by centralised decision-making over the tools they’re allowed to use can end up leaving due to feeling disrespected and disenchanted. On the other hand, there’s also “retention risk” in attracting developers that seek shiny technologies as once these technologies have lost their shine they can leave just as eagerly as they joined. Additionally, in many cases there are technologies that offer an order of magnitude faster/better ways of doing things, and so the best teams will make judgments over _when_ to let their engineers seek “alpha”.

Unchecked restraint in technology choices can eventually lead towards obsolescence and brain drain. Following [“The Golden Path”](https://charity.wtf/2018/12/02/software-sprawl-the-golden-path-and-scaling-teams-with-agency/) and creating a team to centralise technical decisions is a good idea when a company reaches a particular scale, but you must also work out how you’ll create affordances for developers outside of that team to go above the predefined baseline of quality (for a similar idea read _Lethain's_ ["Providing pierceable abstractions"](https://lethain.com/pierceable-abstractions/)).

There are also differences between what individual people and companies. While I might reach into my toolbox and find that my most well-worn tool is JavaScript and use that, another might reach into their toolbox and pick Ruby. We should use what we know best. But what if you’re just starting out? If I was a beginner I would pick an up-and-coming general-purpose programming tool that is growing in usage. While I might benefit from prior knowledge in an older ecosystem, I will learn more by being part of a highly-engaged community of people trying to achieve state-of-the-art approaches. And, what should we recommend to a company that has always written both their application and database logic using SQL Server Stored Procedures? The boring choice might be for them to continue extending and creating new software in this way, but since there is very little beginner interest in learning that stack eventually they will run into hiring problems and brain drain caused by an ageing workforce (institutional knowledge loss). To survive, they will need to rework their system in a way that gives them access to a more fungible workforce.

So how would I make technology choices?

- Use well-understood tools. Either those you personally know well or those that are known well within the broader technology community.
- Use the smallest set of tools you can to solve your problem(s).
- Pay close attention to the happiness of your developers. I'm not suggesting that you should always let the whims of developers dictate a companies overall technology choices, but you should be aware of the market incentives of your employees. In many cases, the work of engineering leaders is to find ways to carve out interesting work within boring/legacy systems.
- Benchmark yourself against you competitors but if a problem is core or complementary to your business look for ways to use technology to gain advantage over them.
